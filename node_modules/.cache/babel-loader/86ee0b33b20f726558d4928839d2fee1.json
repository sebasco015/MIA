{"ast":null,"code":"import { useState as n, useRef as e, useCallback as t, useEffect as o, useLayoutEffect as r } from \"react\";\nimport { flushSync as i } from \"react-dom\";\nimport l from \"raf\";\nimport a from \"tiny-warning\";\n\nfunction c() {\n  return c = Object.assign || function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var o in t) {\n        Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);\n      }\n    }\n\n    return n;\n  }, c.apply(this, arguments);\n}\n\nfunction u(n, e) {\n  if (null == n) return {};\n  var t,\n      o,\n      r = {},\n      i = Object.keys(n);\n\n  for (o = 0; o < i.length; o++) {\n    e.indexOf(t = i[o]) >= 0 || (r[t] = n[t]);\n  }\n\n  return r;\n}\n\nvar d = function d() {};\n\nfunction s(n) {\n  return null != n && n.current ? n.current.scrollHeight : (a(!0, \"useCollapse was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\\n\\n{...getCollapseProps({refKey: 'innerRef'})}\"), \"auto\");\n}\n\nvar f = function f() {\n  var n = arguments;\n  return function () {\n    var e = arguments;\n    return [].slice.call(n).forEach(function (n) {\n      return n && n.apply(void 0, [].slice.call(e));\n    });\n  };\n};\n\nfunction p(n, e) {\n  if (null != n) if (\"function\" == typeof n) n(e);else try {\n    n.current = e;\n  } catch (t) {\n    throw new Error('Cannot assign value \"' + e + '\" to ref \"' + n + '\"');\n  }\n}\n\nvar h = \"undefined\" != typeof window ? r : o,\n    v = !1,\n    g = 0,\n    m = function m() {\n  return ++g;\n},\n    x = [\"duration\", \"easing\", \"collapseStyles\", \"expandStyles\", \"onExpandStart\", \"onExpandEnd\", \"onCollapseStart\", \"onCollapseEnd\", \"isExpanded\", \"defaultExpanded\", \"hasDisabledAnimation\"],\n    y = [\"disabled\", \"onClick\"],\n    E = [\"style\", \"onTransitionEnd\", \"refKey\"];\n\nfunction b(r) {\n  var g,\n      b,\n      C = void 0 === r ? {} : r,\n      w = C.duration,\n      S = C.easing,\n      k = void 0 === S ? \"cubic-bezier(0.4, 0, 0.2, 1)\" : S,\n      O = C.collapseStyles,\n      P = void 0 === O ? {} : O,\n      T = C.expandStyles,\n      D = void 0 === T ? {} : T,\n      K = C.onExpandStart,\n      j = void 0 === K ? d : K,\n      N = C.onExpandEnd,\n      z = void 0 === N ? d : N,\n      A = C.onCollapseStart,\n      H = void 0 === A ? d : A,\n      I = C.onCollapseEnd,\n      M = void 0 === I ? d : I,\n      R = C.isExpanded,\n      q = C.defaultExpanded,\n      B = void 0 !== q && q,\n      V = C.hasDisabledAnimation,\n      _ = void 0 !== V && V,\n      F = u(C, x),\n      G = function (r, i) {\n    var l = n(i || !1),\n        c = l[0],\n        u = l[1],\n        d = e(null != r),\n        s = d.current ? r : c,\n        f = t(function (n) {\n      d.current || u(n);\n    }, []);\n    return o(function () {\n      a(!(d.current && null == r), \"useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.\"), a(!(!d.current && null != r), \"useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.\");\n    }, [r]), [s, f];\n  }(R, B),\n      J = G[0],\n      L = G[1],\n      Q = function (e) {\n    var t = v ? m() : null,\n        r = n(t),\n        i = r[0],\n        l = r[1];\n    return h(function () {\n      null === i && l(m());\n    }, []), o(function () {\n      !1 === v && (v = !0);\n    }, []), null != i ? String(i) : void 0;\n  }(),\n      U = e(null);\n\n  g = U, b = function b(n) {}, \"production\" !== process.env.NODE_ENV && (b = function b(n) {\n    if (null != n && n.current) {\n      var e = window.getComputedStyle(n.current),\n          t = e.paddingTop,\n          o = e.paddingBottom;\n      a(!(t && \"0px\" !== t || o && \"0px\" !== o), \"react-collapsed: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element.\");\n    }\n  }), o(function () {\n    b(g);\n  }, [g]);\n\n  var W,\n      X,\n      Y,\n      Z = (F.collapsedHeight || 0) + \"px\",\n      $ = {\n    display: \"0px\" === Z ? \"none\" : \"block\",\n    height: Z,\n    overflow: \"hidden\"\n  },\n      nn = n(J ? {} : $),\n      en = nn[0],\n      tn = nn[1],\n      on = function on(n) {\n    i(function () {\n      tn(n);\n    });\n  },\n      rn = function rn(n) {\n    on(function (e) {\n      return c({}, e, n);\n    });\n  };\n\n  function ln(n) {\n    if (_) return {};\n\n    var e = w || function (n) {\n      if (!n || \"string\" == typeof n) return 0;\n      var e = n / 36;\n      return Math.round(10 * (4 + 15 * Math.pow(e, .25) + e / 5));\n    }(n);\n\n    return {\n      transition: \"height \" + e + \"ms \" + k\n    };\n  }\n\n  W = function W() {\n    l(J ? function () {\n      j(), rn(c({}, D, {\n        willChange: \"height\",\n        display: \"block\",\n        overflow: \"hidden\"\n      })), l(function () {\n        var n = s(U);\n        rn(c({}, ln(n), {\n          height: n\n        }));\n      });\n    } : function () {\n      H();\n      var n = s(U);\n      rn(c({}, P, ln(n), {\n        willChange: \"height\",\n        height: n\n      })), l(function () {\n        rn({\n          height: Z,\n          overflow: \"hidden\"\n        });\n      });\n    });\n  }, X = [J, Z], Y = e(!0), o(function () {\n    if (!Y.current) return W();\n    Y.current = !1;\n  }, X);\n\n  var an = function an(n) {\n    if (n.target === U.current && \"height\" === n.propertyName) if (J) {\n      var e = s(U);\n      e === en.height ? on({}) : rn({\n        height: e\n      }), z();\n    } else en.height === Z && (on($), M());\n  };\n\n  return {\n    getToggleProps: function getToggleProps(n) {\n      var e = void 0 === n ? {} : n,\n          t = e.disabled,\n          o = void 0 !== t && t,\n          r = e.onClick,\n          i = void 0 === r ? d : r,\n          l = u(e, y);\n      return c({\n        type: \"button\",\n        role: \"button\",\n        id: \"react-collapsed-toggle-\" + Q,\n        \"aria-controls\": \"react-collapsed-panel-\" + Q,\n        \"aria-expanded\": J,\n        tabIndex: 0,\n        disabled: o\n      }, l, {\n        onClick: o ? d : f(i, function () {\n          return L(function (n) {\n            return !n;\n          });\n        })\n      });\n    },\n    getCollapseProps: function getCollapseProps(n) {\n      var e,\n          t = void 0 === n ? {} : n,\n          o = t.style,\n          r = void 0 === o ? {} : o,\n          i = t.onTransitionEnd,\n          l = void 0 === i ? d : i,\n          a = t.refKey,\n          s = void 0 === a ? \"ref\" : a,\n          h = u(t, E);\n      return c({\n        id: \"react-collapsed-panel-\" + Q,\n        \"aria-hidden\": !J\n      }, h, ((e = {})[s] = function () {\n        var n = [].slice.call(arguments);\n        return n.every(function (n) {\n          return null == n;\n        }) ? null : function (e) {\n          n.forEach(function (n) {\n            p(n, e);\n          });\n        };\n      }(U, h[s]), e.onTransitionEnd = f(an, l), e.style = c({\n        boxSizing: \"border-box\"\n      }, r, en), e));\n    },\n    isExpanded: J,\n    setExpanded: L\n  };\n}\n\nexport { b as default };","map":null,"metadata":{},"sourceType":"module"}